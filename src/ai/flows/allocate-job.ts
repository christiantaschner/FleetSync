
// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview An AI agent that suggests the most suitable technician for a new job.
 *
 * - allocateJob - A function that suggests the most suitable technician for a new job.
 */

import {ai} from '@/ai/genkit';
import {
  type AllocateJobInput,
  AllocateJobInputSchema,
  type AllocateJobOutput,
  AllocateJobOutputSchema,
  type DispatcherFeedback,
} from '@/types';
import { dbAdmin } from '@/lib/firebase-admin';
import { collection, query, where, orderBy, limit, getDocs } from 'firebase/firestore';


export async function allocateJob(input: AllocateJobInput): Promise<AllocateJobOutput> {
  // 1. Augment the input with past feedback for the AI
  if (dbAdmin && input.technicianAvailability.length > 0) {
    const firstTech = input.technicianAvailability[0];
    const techDocRef = doc(dbAdmin, 'technicians', firstTech.technicianId);
    const companyId = (await getDoc(techDocRef)).data()?.companyId;

    if (companyId) {
        const feedbackQuery = query(
            collection(dbAdmin, `artifacts/${process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID}/public/data/dispatcherFeedback`),
            where("companyId", "==", companyId),
            orderBy("createdAt", "desc"),
            limit(5) // Get the last 5 feedback examples
        );
        const feedbackSnapshot = await getDocs(feedbackQuery);
        const pastFeedback = feedbackSnapshot.docs.map(doc => doc.data() as DispatcherFeedback);
        input.pastFeedback = pastFeedback;
    }
  }
  
  // 2. Call the flow with the augmented input
  return allocateJobFlow(input);
}

const prompt = ai.definePrompt({
  name: 'allocateJobPrompt',
  model: 'googleai/gemini-1.5-flash-latest',
  input: {schema: AllocateJobInputSchema},
  output: {schema: AllocateJobOutputSchema},
  prompt: `You are an AI assistant helping dispatchers allocate jobs to field technicians. Your decision must be based on a balance of skill, availability, location, and individual schedules.
You must also learn from past dispatcher decisions.

**TASK:**
Given the following job and technician data, suggest the most suitable technician.

**Job Details:**
- Description: {{{jobDescription}}}
- Priority: {{{jobPriority}}}
{{#if scheduledTime}}- Customer Requested Time: {{{scheduledTime}}} (This is a strong preference).{{/if}}

{{#if requiredSkills.length}}
**CRITICAL SKILL REQUIREMENT:** The job explicitly requires the following skills: {{#each requiredSkills}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}. The chosen technician MUST possess ALL of these skills. This is a non-negotiable constraint.
{{/if}}

**Technician Data:**
{{#each technicianAvailability}}
- **Technician ID: {{{technicianId}}}**
  - Name: {{{technicianName}}}
  - Available Now: {{{isAvailable}}}
  - On Call for Emergencies: {{#if isOnCall}}Yes{{else}}No{{/if}}
  - Skills: {{#if skills}}{{#each skills}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None listed{{/if}}
  - Location: (Lat: {{{location.latitude}}}, Lon: {{{location.longitude}}})
  {{#if currentJobs.length}}
  - Current Assigned Jobs:
    {{#each currentJobs}}
    - Job ID: {{{jobId}}}, Priority: {{{priority}}}{{#if scheduledTime}}, Scheduled: {{{scheduledTime}}}{{/if}}
    {{/each}}
  {{/if}}
  {{#if workingHours}}
  - Working Hours:
    {{#each workingHours}}
    - {{dayOfWeek}}: {{#if isOpen}}{{startTime}} - {{endTime}}{{else}}Off{{/if}}
    {{/each}}
  {{/if}}
{{/each}}

---
**LEARNING FROM PAST DECISIONS:**
Analyze the following examples where a human dispatcher overrode the AI's suggestion. These reveal the company's hidden preferences. Learn from them.
{{#if pastFeedback.length}}
  {{#each pastFeedback}}
  - **Example:** For Job #{{{jobId}}}, the AI suggested Technician #{{{aiSuggestedTechnicianId}}} because "{{{aiReasoning}}}". The dispatcher disagreed and chose Technician #{{{dispatcherSelectedTechnicianId}}} instead.
  {{/each}}
{{else}}
- No past feedback available. Use standard logic.
{{/if}}
---

**DECISION-MAKING LOGIC:**

1.  **Learn from Feedback**: First, analyze the 'LEARNING FROM PAST DECISIONS' section. Identify patterns. Did the dispatcher prefer a more experienced tech even if they were further away? Do they avoid interrupting certain techs? Let these examples heavily influence your final choice.
2.  **Skill Match**: The technician MUST have ALL \`requiredSkills\`. If no technician has the required skills, no one is suitable.
3.  **Job Priority & Scheduling Logic:**
    *   **If the job priority is 'High':**
        *   Your absolute top priority is to find an available technician who is marked as **\`isOnCall: true\`**. If one exists and is skilled, suggest them immediately.
        *   If no 'On Call' technician is available, STRONGLY prefer any other technician who is \`isAvailable: true\` and skilled. Choose the closest one. Their future \`currentJobs\` for later in the day do not matter for this decision.
        *   If NO technician is \`isAvailable: true\`, you MAY suggest a technician who is \`isAvailable: false\` BUT is currently working on a 'Low' priority job. This is an interruption.
        *   NEVER suggest interrupting a technician on a 'Medium' or 'High' priority job.
    *   **If the job priority is 'Medium' or 'Low':**
        *   Only consider technicians who are \`isAvailable: true\` and skilled.
        *   The suggested assignment time MUST respect the technician's individual \`workingHours\`. Do not suggest a technician if the job would fall outside their scheduled shift for the day.
        *   Consider their \`currentJobs\` to ensure they have capacity.

---
Provide a clear reasoning for your choice, explicitly mentioning how past feedback influenced your decision if applicable. Refer to technicians by name, not ID. If you suggest an interruption, state it clearly. If no technician is suitable, explain why.
`,
});

const allocateJobFlow = ai.defineFlow(
  {
    name: 'allocateJobFlow',
    inputSchema: AllocateJobInputSchema,
    outputSchema: AllocateJobOutputSchema,
  },
  async input => {
    try {
      const { output } = await prompt(input);
      if (!output) {
        return {
          suggestedTechnicianId: null,
          reasoning: "The AI model could not determine a suitable technician based on the provided constraints (e.g., skills, availability) or generated an invalid response.",
        };
      }
      return output;
    } catch (error) {
      return {
        suggestedTechnicianId: null,
        reasoning: `The AI model encountered an error during processing: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  }
);
