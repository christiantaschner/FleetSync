
// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview An AI agent that suggests the most suitable technician for a new job.
 *
 * - allocateJob - A function that suggests the most suitable technician for a new job.
 */

import {ai} from '@/ai/genkit';
import {
  type AllocateJobInput,
  AllocateJobInputSchema,
  type AllocateJobOutput,
  AllocateJobOutputSchema,
  type DispatcherFeedback,
} from '@/types';
import { dbAdmin } from '@/lib/firebase-admin';
import { collection, query, where, orderBy, limit, getDocs, doc, getDoc } from 'firebase/firestore';


export async function allocateJob(input: AllocateJobInput, appId: string): Promise<AllocateJobOutput> {
  // 1. Augment the input with past feedback for the AI
  if (dbAdmin && input.technicianAvailability.length > 0) {
    const firstTech = input.technicianAvailability[0];
    const techDocRef = doc(dbAdmin, `artifacts/${appId}/public/data/technicians`, firstTech.technicianId);
    const companyId = (await getDoc(techDocRef)).data()?.companyId;

    if (companyId) {
        const feedbackCollectionRef = collection(dbAdmin, `artifacts/${appId}/public/data/dispatcherFeedback`);
        const feedbackQuery = query(
            feedbackCollectionRef,
            where("companyId", "==", companyId),
            orderBy("createdAt", "desc"),
            limit(5) // Get the last 5 feedback examples
        );
        const feedbackSnapshot = await getDocs(feedbackQuery);
        const pastFeedback = feedbackSnapshot.docs.map(doc => doc.data() as DispatcherFeedback);
        input.pastFeedback = pastFeedback;
    }
  }
  
  // 2. Call the flow with the augmented input
  return allocateJobFlow(input);
}

const prompt = ai.definePrompt({
  name: 'allocateJobPrompt',
  model: 'googleai/gemini-1.5-flash-latest',
  input: {schema: AllocateJobInputSchema},
  output: {schema: AllocateJobOutputSchema},
  prompt: `You are an AI assistant helping dispatchers allocate jobs to field technicians. Your decision must be based on a balance of skill, availability, location, customer history, and individual schedules.
You must also learn from past dispatcher decisions.

The current time is {{{currentTime}}}.

**TASK:**
Given the following job and technician data, suggest the most suitable technician.

**Job Details:**
- Description: {{{jobDescription}}}
- Priority: {{{jobPriority}}}
{{#if scheduledTime}}
- Customer Requested Time: {{{scheduledTime}}}. You must determine if this is for today or a future day by comparing it to the current time.
{{else}}
- No specific time requested. Assume the job is for as soon as possible (today).
{{/if}}

{{#if requiredSkills.length}}
**CRITICAL SKILL REQUIREMENT:** The job explicitly requires the following skills: {{#each requiredSkills}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}. The chosen technician MUST possess ALL of these skills. This is a non-negotiable constraint.
{{/if}}

**Technician Data:**
{{#each technicianAvailability}}
- **Technician ID: {{{technicianId}}}**
  - Name: {{{technicianName}}}
  - Available Now: {{{isAvailable}}}
  - On Call for Emergencies: {{#if isOnCall}}Yes{{else}}No{{/if}}
  - **Previous Customer History: {{#if hasCustomerHistory}}Yes{{else}}No{{/if}}**
  - Skills: {{#if skills}}{{#each skills}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None listed{{/if}}
  - Live Location: (Lat: {{{liveLocation.latitude}}}, Lon: {{{liveLocation.longitude}}})
  - Home Base: {{{homeBaseLocation.address}}}
  {{#if currentJobs.length}}
  - Current Assigned Jobs for Today/Tomorrow:
    {{#each currentJobs}}
    - Job ID: {{{jobId}}}, Location: ({{{location.latitude}}}, {{{location.longitude}}}), Priority: {{{priority}}}{{#if scheduledTime}}, Scheduled: {{{scheduledTime}}}{{/if}}, Started At: {{#if startedAt}}{{{startedAt}}}{{else}}Not Started{{/if}}, Est. Duration: {{{estimatedDurationMinutes}}} mins
    {{/each}}
  {{else}}
  - No jobs currently assigned.
  {{/if}}
  {{#if workingHours}}
  - Working Hours:
    {{#each workingHours}}
    - {{dayOfWeek}}: {{#if isOpen}}{{startTime}} - {{endTime}}{{else}}Off{{/if}}
    {{/each}}
  {{else}}
  - No defined working hours. Assume standard 8 AM to 5 PM.
  {{/if}}
{{/each}}

---
**LEARNING FROM PAST DECISIONS:**
Analyze the following examples where a human dispatcher overrode the AI's suggestion. These reveal the company's hidden preferences. Learn from them.
{{#if pastFeedback.length}}
  {{#each pastFeedback}}
  - **Example:** For Job #{{{jobId}}}, the AI suggested Technician #{{{aiSuggestedTechnicianId}}} because "{{{aiReasoning}}}". The dispatcher disagreed and chose Technician #{{{dispatcherSelectedTechnicianId}}} instead.
  {{/each}}
{{else}}
- No past feedback available. Use standard logic.
{{/if}}
---

**DECISION-MAKING LOGIC (STEP 1):**

1.  **Determine Job Day**: First, decide if the job is for **today** or a **future day** by comparing its scheduled time to the current time.

2.  **Availability Check**:
    -   For jobs scheduled for **TODAY**: The technician's 'isAvailable' status is paramount. Prioritize technicians who are 'isAvailable: true'.
    -   For jobs scheduled for a **FUTURE DAY**: The 'isAvailable' status (which reflects their status *right now*) is LESS important. Instead, check their 'currentJobs' list to see if they are already booked on that future day. A technician who is 'isAvailable: false' now can still be assigned a job for tomorrow if their schedule is open.

3.  **Customer History Preference**: If a technician has 'Previous Customer History', they should be **strongly prioritized** over others, provided they meet all other critical requirements (skills, availability). This reflects an established customer relationship which is very valuable.
---
Provide a clear reasoning for your choice, explicitly mentioning how customer history, skill match, and availability (current or estimated future) influenced your decision. Refer to technicians by name, not ID. If no technician is suitable, explain why.
`,
});

const allocateJobFlow = ai.defineFlow(
  {
    name: 'allocateJobFlow',
    inputSchema: AllocateJobInputSchema,
    outputSchema: AllocateJobOutputSchema,
  },
  async input => {
    try {
      const { output } = await prompt(input);
      if (!output) {
        return {
          suggestedTechnicianId: null,
          reasoning: "The AI model could not determine a suitable technician based on the provided constraints (e.g., skills, availability) or generated an invalid response.",
        };
      }
      return output;
    } catch (error) {
      console.error('Error in allocateJobFlow:', error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      // Check for specific Firestore-related error messages
      if (errorMessage.includes('firestore') || errorMessage.includes('collection()')) {
        return {
          suggestedTechnicianId: null,
          reasoning: `An internal database error occurred while trying to access learning data. ${errorMessage}`,
        };
      }
      return {
        suggestedTechnicianId: null,
        reasoning: `The AI model encountered an error during processing: ${errorMessage}`,
      };
    }
  }
);
